#!/bin/bash

create_encrypted () {
	# file is now a gz file
	gzip $backup
	enc_backup="${backup}.gz.dat"
	# encrypt it
	openssl enc -aes-256-cbc -pbkdf2 -e -pass pass:$encryption_password \
	< "${backup}.gz" \
	> $enc_backup
	#delete the tar.gz file
	rm "${backup}.gz"
	#upload it to back blaze
	small_file
	#delete the dat file
	rm $enc_backup 
}

large_file () {
:
}

small_file () {
	# get the url to upload the data to
	uploadurl_response=$(curl -s -H "Authorization: $token" \
	--data "{\"bucketId\": \"${bucketid}\"}" "${apiurl}b2_get_upload_url")
	check_for_bad_request "$uploadurl_response"
	
	uploadurl=$(echo $uploadurl_response | jq -r '.uploadUrl')
	uploadtoken=$(echo $uploadurl_response | jq -r '.authorizationToken')
	sha1_of_file=$(openssl dgst -sha1 $enc_backup | awk '{print $2;}')
	
	# upload the file
	upload_response=$(curl \
	-H "Authorization: $uploadtoken" \
	-H "X-Bz-File-Name: $enc_backup" \
	-H "Content-Type: application/octet-stream" \
	-H "X-Bz-Content-Sha1: $sha1_of_file" \
	--data-binary "@$enc_backup" \
	$uploadurl)
	check_for_bad_request "$upload_response"

	echo $upload_response | jq .
}

check_for_bad_request () {
    if [ $(echo "$1" | jq '.status') != null ];
    then
		printf "Backblaze returned error\n"
		printf "$1" | jq '.'
		exit 1
    fi
}

cd /usr/local/emhttp/plugins/bucketbackup/

app_id=$(cat settings.config | jq -r '.app_id')
app_key=$(cat settings.config | jq -r '.app_key')
backup_locations=$(cat settings.config | jq '.backup_location')
bucket_type=$(cat settings.config | jq '.bucket_type')
encryption_password=$(cat settings.config | jq -r '.encryption_password')
authurl=$(printf "https://api.backblazeb2.com/b2api/v2/")

authresponse=$(curl -s  "${authurl}b2_authorize_account" -u "${app_id}:${app_key}")
check_for_bad_request "$authresponse"

#response from backblaze that will be used for sending files
token=$(echo $authresponse | jq -r '.authorizationToken')
apiurl=$(echo $authresponse | jq -r '.apiUrl')
apiurl+="/b2api/v2/"
accountid=$(echo $authresponse | jq -r '.accountId')
size_of_part=$( echo $authresponse | jq -r '.recommendedPartSize')
minimum_part_size=$( echo $authresponse | jq -r '.absoluteMinimumPartSize')

#create a new bucket to hold the backup
# the name is the current date and time
bucketname=$(date +"%m-%d-%Y-%H-%M-%S")
buckettype="allPrivate"
bucketcreate_response=$(curl -s -H  "Authorization: $token" \
	--data "{\"accountId\":\"${accountid}\",\"bucketName\":\"${bucketname}\",\"bucketType\":\"${buckettype}\"}" \
	"${apiurl}b2_create_bucket")
check_for_bad_request "$bucketcreate_response"
bucketid=$(echo $bucketcreate_response | jq -r '.bucketId')

#change directory to the array so the storage space on the flash drive isn't completely taken up
cd /mnt/user/

declare -i filecount=0
backup="backup${filecount}.tar"

for row in $(echo ${backup_locations} | jq -r .[]);
do
	target=$(echo ${row} | sed '/^\// s/.//')
	while IFS= read -d '' -r file; do
		target=$(echo "${file}" | sed '/^\// s/.//')
		if test -f $backup;
		then
			#append to the current backup
			tar rf $backup -C / "$target"
		else
			# create a new tar file
			tar cf $backup -C / "$target"
		fi

		if [ $(du -s $backup | awk '{ print $1 }') -gt 117558 ];
		then
			# archive size has been reached. gzip it, encrypt it and send it by either backblazes regular or large file upload routine
			create_encrypted
			#since the previous batch of files have been uploaded, move on to the next
			filecount+=1
			backup="backup${filecount}.tar"
		fi
	done < <(find ${row} -type f -follow -print0)
done

# check to see if backup file still exists. If it does then there are still some more files that need to be uploaded
if test -f $backup;
then
	if [ $(du -s $backup | awk '{ print $1 }') -gt 5000000000 ];
	then
		: #create large file
	else
		create_encrypted
	fi
fi
